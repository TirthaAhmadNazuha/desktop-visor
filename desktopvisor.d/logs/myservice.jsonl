["2024-07-27T22:59:58.425Z","base_images\nchromium_data\nconfig\ndata\ndata_browser\nDesktop\nDocuments\nDownloads\nMusic\nPictures\nPublic\nrtl8821ce\nself_works\nsliceblob\nsnap\nTemplates\nVideos\nworks\nworks.tar.gz"]
["2024-07-27T23:08:29.964Z","{\n  \"name\": \"cli\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\"\n}"]
["2024-07-27T23:09:51.574Z","import { readFile, writeFile } from 'fs/promises'\nimport { createConnection, Socket } from 'net'\nimport path from 'path'\n\n\nasync function main() {\n    const [command, ...args] = process.argv.slice(2)\n    let confg = null\n    if (command == 'use') {\n        await writeFile(new URL('used_config.json', import.meta.url), await readFile(new URL(`configs/${args.join(' ').trim()}.json`, import.meta.url)))\n    }\n    try {\n        confg = JSON.parse(await readFile(new URL('used_config.json', import.meta.url)) || '{}')\n        if (!confg.hostname || !confg.port) return console.log(`config incorrect!\\nexample: ${JSON.stringify({ hostname: '127.0.0.1', port: 4732 })}`)\n    } catch (error) {\n        return console.log(`config incorrect!\\nexample: ${JSON.stringify({ hostname: '127.0.0.1', port: 4732 })}`)\n    }\n    const socket = new Socket()\n    await new Promise(r => socket.connect({ host: confg.hostname, port: confg.port }, r))\n    let res = null\n    switch (command) {\n        case 'apply':\n            const serviceConf = await readFile(args.join(' ').trim())\n            socket.write(JSON.stringify({ apply: JSON.parse(serviceConf) }))\n            res = await new Promise(r => socket.once('data', r))\n            console.log(res.toString())\n            break\n        case 'status':\n            socket.write(JSON.stringify({ status: { name: args[0] } }))\n            res = await new Promise(r => socket.once('data', r))\n            console.log(res.toString())\n            break\n        case 'start':\n            socket.write(JSON.stringify({ start: { name: args[0] } }))\n            res = await new Promise(r => socket.once('data', r))\n            console.log(res.toString())\n            break\n        case 'restart':\n            socket.write(JSON.stringify({ restart: { name: args[0] } }))\n            res = await new Promise(r => socket.once('data', r))\n            console.log(res.toString())\n            break\n        case 'stop':\n            socket.write(JSON.stringify({ stop: { name: args[0] } }))\n            res = await new Promise(r => socket.once('data', r))\n            console.log(res.toString())\n            break\n        case 'logs':\n            socket.write(JSON.stringify({ logs: { name: args[0] } }))\n            res = (await new Promise(r => socket.once('data', r))).toString()\n            if (args[1] == 'raw' || res.startsWith('invalid, get logs')) {\n                console.log(res)\n            } else {\n                res.split('\\n').filter(s => s).forEach((log) => {\n                    const [date, l] = JSON.parse(log)\n                    console.log(`[${date}]:\\n    ${l.replaceAll('\\n', `\\n    `)}`)\n                })\n            }\n    }\n    await new Promise(r => socket.end(r))\n}\nmain()"]
